class Solution {
    public int hb(List<Integer> l){
        int prev1 = l.get(0);
        int prev2 = Math.max(l.get(0), l.get(1));
        for(int i=2;i<l.size();i++){
            int cur = Math.max(prev2, prev1 + l.get(i));
            prev1 = prev2;
            prev2 = cur;
        }
        return prev2;
    }
    public int rob(int[] nums) {
        if(nums.length==1){
            return nums[0];
        }
        if(nums.length==2){
            return Math.max(nums[0], nums[1]);
        }
        List<Integer> l = new ArrayList<>();
        List<Integer> l2 = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            if(i!=0){
                l.add(nums[i]);
            }
            if(i!=nums.length-1){
                l2.add(nums[i]);
            }
        }
        int s1 = hb(l);
        int s2 = hb(l2);
        return Math.max(s1, s2);
    }
}

// TABULATION 
public class Solution {
    public int uniquePathsWithObstacles(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        int[][] dp = new int[m][n];

        // If starting point is obstacle
        if (grid[0][0] == 1)
            return 0;

        dp[0][0] = 1; // Start position

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    dp[i][j] = 0; // Obstacle
                } else if (!(i == 0 && j == 0)) {
                    int up = (i > 0) ? dp[i - 1][j] : 0;
                    int left = (j > 0) ? dp[i][j - 1] : 0;
                    dp[i][j] = up + left;
                }
            }
        }

        return dp[m - 1][n - 1];
    }
}
// RECURISION + MEMOIZATION
import java.util.Arrays;

public class Solution {
    public int uniquePathsWithObstacles(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        
        // If start or end cell is blocked
        if (grid[0][0] == 1 || grid[m-1][n-1] == 1)
            return 0;

        int[][] dp = new int[m][n];
        for (int[] row : dp)
            Arrays.fill(row, -1);

        return countPaths(m - 1, n - 1, grid, dp);
    }

    public int countPaths(int i, int j, int[][] grid, int[][] dp) {
        // Out of bounds
        if (i < 0 || j < 0)
            return 0;

        // Obstacle
        if (grid[i][j] == 1)
            return 0;

        // Starting point
        if (i == 0 && j == 0)
            return 1;

        // Memoized
        if (dp[i][j] != -1)
            return dp[i][j];

        int up = countPaths(i - 1, j, grid, dp);
        int left = countPaths(i, j - 1, grid, dp);

        return dp[i][j] = up + left;
    }
}
