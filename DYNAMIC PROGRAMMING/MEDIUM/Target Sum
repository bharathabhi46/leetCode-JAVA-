// RECURSION + MEMOIZATION
class Solution {
    static int dp[][];
    public int nW(int arr[], int n, int k){
        if(n==0){
            if(k == 0 && arr[0]==0){
                return 2;
            }
            if(k == 0 || k == arr[0]){
                return 1;
            }
            return 0;
        }
        if(dp[n][k]!=-1){
            return dp[n][k];
        }
        int ex = nW(arr, n-1, k);
        int in = 0;
        if(arr[n]<=k){
            in = nW(arr, n-1, k-arr[n]);
        }
        return dp[n][k]  = in+ex;
    }
    public int findTargetSumWays(int[] nums, int target) {
        int n = nums.length;
        int tS = 0;
        for(int i=0;i<n;i++){
            tS+=nums[i];
        }
        if(tS-target<0 || (tS-target)%2!=0){
            return 0;
        }
        dp = new int[n][((tS-target)/2)+1];
        for(int i=0;i<n;i++){
            for(int j=0;j<=(tS-target)/2;j++){
                dp[i][j] = -1;
            }
        }
        return nW(nums, n-1, (tS-target)/2);
    }
}
// TABULATION
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int n = nums.length;
        int tS = 0;
        for (int i = 0; i < n; i++) {
            tS += nums[i];
        }
        if (tS - target < 0 || (tS - target) % 2 != 0) {
            return 0;
        }
        int sum = (tS - target) / 2;
        int dp[][] = new int[n][sum + 1];
        if (nums[0] == 0) dp[0][0] = 2;
        else dp[0][0] = 1;
        if (nums[0] != 0 && nums[0] <= sum) dp[0][nums[0]] = 1;
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= sum; j++) {
                int ex = dp[i - 1][j];
                int in = 0;
                if (nums[i] <= j) in = dp[i - 1][j - nums[i]];
                dp[i][j] = ex + in;
            }
        }
        return dp[n - 1][sum];
    }
}

