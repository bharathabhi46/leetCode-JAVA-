// RECURSION + MEMOIZATION
class Solution {
    static int dp[][];
    public static boolean f(int arr[], int n, int k){
        if(k==0){
            return true;
        }
        if(n==0){
            return arr[0]==k;
        }
        if(dp[n][k]!=-1){
            return dp[n][k] == 1;
        }
        boolean nT = f(arr, n-1, k);
        boolean T = false;
        if(arr[n]<=k){
            T = f(arr, n-1, k-arr[n]);
        }
        dp[n][k] = (T || nT) ? 1 : 0;
        return dp[n][k] == 1;
    }
    static boolean equalPartition(int arr[]) {
        int n = arr.length;
        int sum = 0;
        for(int i=0;i<n;i++){
            sum+=arr[i];
        }
        if(sum%2!=0){
            return false;
        }
        int k = sum/2;
        dp = new int[n][k+1];
        for(int i=0;i<n;i++){
            for(int j=0;j<=k;j++){
                dp[i][j] = -1;
            }
        }
        return f(arr, n-1, k);
    }
}
// TABULATION
class Solution {
    static boolean equalPartition(int arr[]) {
        int n = arr.length;
        int sum = 0;
        for(int i=0;i<n;i++) sum += arr[i];
        if(sum % 2 != 0) return false;
        int k = sum / 2;
        boolean[][] dp = new boolean[n][k+1];
        for(int i=0;i<n;i++) dp[i][0] = true;
        if(arr[0] <= k) dp[0][arr[0]] = true;
        for(int i=1;i<n;i++){
            for(int target=1; target<=k; target++){
                boolean notTake = dp[i-1][target];
                boolean take = false;
                if(arr[i] <= target) take = dp[i-1][target-arr[i]];
                dp[i][target] = take || notTake;
            }
        }
        return dp[n-1][k];
    }
}
// SPACE OPTMIZATION
class Solution {
    static boolean equalPartition(int arr[]) {
        int n = arr.length;
        int sum = 0;
        for(int i=0;i<n;i++) sum += arr[i];
        if(sum % 2 != 0) return false;
        int k = sum / 2;
        boolean[] prev = new boolean[k+1];
        prev[0] = true;
        if(arr[0] <= k) prev[arr[0]] = true;
        for(int i=1;i<n;i++){
            boolean[] cur = new boolean[k+1];
            cur[0] = true;
            for(int target=1; target<=k; target++){
                boolean notTake = prev[target];
                boolean take = false;
                if(arr[i] <= target) take = prev[target-arr[i]];
                cur[target] = take || notTake;
            }
            prev = cur;
        }
        return prev[k];
    }
}
